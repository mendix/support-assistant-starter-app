// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package pgvectorknowledgebase.actions;

import com.mendix.core.Core;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.systemwideinterfaces.core.meta.IMetaObject;
import com.mendix.webui.CustomJavaAction;
import pgvectorknowledgebase.impl.ChunkUtils;
import pgvectorknowledgebase.impl.MxLogger;
import pgvectorknowledgebase.proxies.Chunk;

/**
 * Use this operation to retrieve chunks from the knowledge base and set associations to the related mendix objects (if applicable). This operation returns a list of the same type of the TargetChunk input variable. 
 * Additional selection and filtering can be done by specifying the optional input parameters:
 * -Offset: number of records to skip (for batching purposes)
 * -MaxNumberOfResults: limit of the amount of records returned
 * -LabelList: when provided, this operation only returns chunks that are conform with all of the labels in the list.
 * 
 * The DatabaseConfiguration that is passed must contain the connection details to a PostgreSQL database server with the PgVector extension installed. This entity is typically configured at runtime or in after-startup logic.
 * By providing the KnowledgeBaseName parameter, you determine the knowledge base that was used for population earlier. 
 * The TargetChunk entity (type parameter) must be a specialization of the Chunk entity from this module. If it contains associations to (specializations of) the related mendix object for which the chunk was created, this will be set by this operation for easy processing afterwards.
 */
public class ChunkList_Retrieve_SetAssociation extends CustomJavaAction<java.util.List<IMendixObject>>
{
	/** @deprecated use DatabaseConfiguration.getMendixObject() instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final IMendixObject __DatabaseConfiguration;
	private final pgvectorknowledgebase.proxies.DatabaseConfiguration DatabaseConfiguration;
	private final java.lang.String KnowledgeBaseName;
	private final java.lang.String TargetChunk;
	/** @deprecated use com.mendix.utils.ListUtils.map(LabelList, com.mendix.systemwideinterfaces.core.IEntityProxy::getMendixObject) instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final java.util.List<IMendixObject> __LabelList;
	private final java.util.List<pgvectorknowledgebase.proxies.Label> LabelList;
	private final java.lang.Long MaxNumberOfResults;
	private final java.lang.Long Offset;

	public ChunkList_Retrieve_SetAssociation(
		IContext context,
		IMendixObject _databaseConfiguration,
		java.lang.String _knowledgeBaseName,
		java.lang.String _targetChunk,
		java.util.List<IMendixObject> _labelList,
		java.lang.Long _maxNumberOfResults,
		java.lang.Long _offset
	)
	{
		super(context);
		this.__DatabaseConfiguration = _databaseConfiguration;
		this.DatabaseConfiguration = _databaseConfiguration == null ? null : pgvectorknowledgebase.proxies.DatabaseConfiguration.initialize(getContext(), _databaseConfiguration);
		this.KnowledgeBaseName = _knowledgeBaseName;
		this.TargetChunk = _targetChunk;
		this.__LabelList = _labelList;
		this.LabelList = java.util.Optional.ofNullable(_labelList)
			.orElse(java.util.Collections.emptyList())
			.stream()
			.map(labelListElement -> pgvectorknowledgebase.proxies.Label.initialize(getContext(), labelListElement))
			.collect(java.util.stream.Collectors.toList());
		this.MaxNumberOfResults = _maxNumberOfResults;
		this.Offset = _offset;
	}

	@java.lang.Override
	public java.util.List<IMendixObject> executeAction() throws Exception
	{
		// BEGIN USER CODE
		
		try { 
			IMetaObject targetChunk = Core.getMetaObject(TargetChunk);
			ChunkUtils.validateTargetChunk(targetChunk);
			
			// call a microflow to retrieve chunks
			java.util.List<Chunk> chunkList = pgvectorknowledgebase.proxies.microflows.Microflows.chunkList_Retrieve(
					getContext(), DatabaseConfiguration, KnowledgeBaseName, MaxNumberOfResults, LabelList, Offset);
			
			//map to target chunks to return
			return ChunkUtils.getTargetChunkList(getContext(), chunkList, targetChunk);
			
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
			throw e;
		}
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "ChunkList_Retrieve_SetAssociation";
	}

	// BEGIN EXTRA CODE
	private static final MxLogger LOGGER = new MxLogger(ChunkList_Retrieve_SetAssociation.class);
	// END EXTRA CODE
}
